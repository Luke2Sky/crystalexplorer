#include "isosurface_calculator.h"
#include "occsurfacetask.h"
#include "load_mesh.h"
#include <occ/core/element.h>
#include <QFile>
#include <QTextStream>

void write_xyz_file(const QString &filename, const occ::IVec &nums, const occ::Mat3N &positions) {
    if (nums.rows() != positions.cols()) {
	qDebug() << "Invalid write xyz call, mismatch in nums and positions size";
        return;
    }

    QFile file(filename);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
	qDebug() << "Could not open file for writing in write_xyz_file";
        return;
    }

    QTextStream out(&file);
    
    out << nums.size() << "\n";
    out << "XYZ file generated by IsosurfaceCalculator" << "\n";

    for (int i = 0; i < nums.size(); ++i) {
        auto sym = QString::fromStdString(occ::core::Element(nums(i)).symbol());
        const auto pos = positions.col(i);
        out << sym << " " << pos(0) << " " << pos(1) << " " << pos(2) << "\n";
    }

    file.close();
    qDebug() << "Wrote xyz file to" << QFileInfo(file).absolutePath() << filename;
}

void write_wavefunction_file(const QString &filename, MolecularWavefunction *wfn) {
    if(!wfn) return;
    QFile file(filename);
    if (file.open(QIODevice::WriteOnly)) {
	file.write(wfn->rawContents());
	file.close();
    }
    else {
	qDebug() << "Could not open file for writing in write_wavefunction_file";
    }

}

namespace volume {

IsosurfaceCalculator::IsosurfaceCalculator(QObject * parent) : QObject(parent) {}

void IsosurfaceCalculator::setTaskManager(TaskManager *mgr) {
    m_taskManager = mgr;
}

void IsosurfaceCalculator::start(isosurface::Parameters params) {
  if(!params.structure) {
    qDebug() << "Found nullptr for chemical structure in IsosurfaceCalculator";
    return;
  }
  m_structure = params.structure;

  QString filename, filename_outside;
  m_atoms = {};

  if(params.kind == isosurface::Kind::Void) {
      filename = "crystal.cif";
  }
  else {
      m_atoms = params.structure->atomsWithFlags(AtomFlag::Selected);
      occ::IVec nums = params.structure->atomicNumbersForIndices(m_atoms);
      occ::Mat3N pos = params.structure->atomicPositionsForIndices(m_atoms);

      if(params.wfn) {
	filename = "ce_surface_inside.owf.json";
	write_wavefunction_file(filename, params.wfn);
      }
      else {
	filename = "ce_surface_inside.xyz";
	write_xyz_file(filename, nums, pos);
      }
      filename_outside = "ce_surface_outside.xyz";

      {
	  auto idxs = params.structure->atomsSurroundingAtomsWithFlags(AtomFlag::Selected, 12.0);
	  qDebug() << "Idxs size: " << idxs.size();
	  auto nums_outside = params.structure->atomicNumbersForIndices(idxs);
	  auto pos_outside = params.structure->atomicPositionsForIndices(idxs);
	  write_xyz_file(filename_outside, nums_outside, pos_outside);
      }
  }

  QString surfaceName = isosurface::kindToString(params.kind);
  OccSurfaceTask * surface_task = new OccSurfaceTask();
  surface_task->setSurfaceParameters(params);
  surface_task->setProperty("name", surfaceName);
  surface_task->setProperty("inputFile", filename);
  surface_task->setProperty("environmentFile", filename_outside);
  qDebug() << "Generating " << isosurface::kindToString(params.kind) << "surface with isovalue: " << params.isovalue;
  surface_task->setProperty("isovalue", params.isovalue);

  auto taskId = m_taskManager->add(surface_task);
  m_name = surfaceName;
  m_filename = "surface.ply";

  connect(surface_task, &Task::completed, this, &IsosurfaceCalculator::surfaceComplete);
}

void IsosurfaceCalculator::surfaceComplete() {
    qDebug() << "Task" << m_name << "finished in IsosurfaceCalculator";
    Mesh * mesh = io::loadMesh(m_filename);
    mesh->setObjectName(m_name);
    mesh->setAtoms(m_atoms);
    mesh->setParent(m_structure);
}

}
